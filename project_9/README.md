## Проект 9: Алгоритм контроля перегрузки Backpressure на C++
## Студент: Левченко Богдан

### Хочеться 
* "per-hop per-flow control", то есть быстро реагировать на текущее состояние сети и сделать потоки данных независимыми 
* уложиться в ограниченные возможности свитча

### Концепция и ключевые идеи
Свитч состоит из трёх логических частей - 
1. Сопоставления входящих пакетов в определённые очереди
2. Анализа заполненности очередей и отправки "backpressure feedback" на предыдущий свитч
3. Планирования обработки (передачи на следующий свитч) пакетов с учётом полученного "backpressure feedback"

Основные идеи дизайна решения
1. Отслеживаем только активные потоки данных, то есть пакеты которых есть в очереди свитча. Сами очереди в свитче FIFO, а планировщик опрашивает очереди по порядку, что даёт меньшее количество активных потоков
2. При назначении очереди потоку выбираем очередь с наименьшим числом уже назначенных активных потоков и с наименьшим номером. Это даёт меньшее количество колизий между потоками
3. Если, после добавления пакета в очередь Q1, её размер стал больше определённого порога (не равного capacity самой очереди), то приостанавливаем отправку пакетов очереди Q2, из которой этот пакет вышел на предыдущем свитче. Для этого прямо в пакете храним информацию о назначенной очереди на предыдущем свитче. Приостановленная очередь Q2 продолжает свою работу, когда размер очереди Q1 станет меньше порога. Причем если Q2 была заблокированна несколькими очередями Qx, то она ждёт пока все размеры очередей Qx станут меньше порога. 

### Подробнее как происходит BFC

У каждой очереди в свитче есть счётчик пауз, который увеличивается или уменьшается, если приходит информация о заполненности очереди на следующем свитче, и счётчик активных потоков, который показывает количество активных потоков в очереди. 

Имеется map flowTable который хранит число пакетов каждого потока и назначеный номер очереди.
В качестве ключа в map берётся хэш информация пакета, которая одиннаковая для всех пакетов этого потока (SRC, DIST). 
Число пакетов используем чтобы сразу после последнего пакета уменьшить счётчик активных очередей. 

Если, после добавления пакета в очередь, её размер стал больше определённого порога, то пакет помечается как counterInc. 
В качестве ключа в map берётся хэш информация пакета, которая одиннаковая для всех пакетов из предыдущего свитча определённой очереди (SRC, DIST, upstreamQ)
Это используется в map pauseCounter который хранит количество пакетов с counterInc для очереди в предыдущем пакете. Как и в flowTable, число таких пакетов используем чтобы сразу после последнего пакета отправить сообщение предыдущему свитчу, о том что можно продолжать передавать данные с этой очереди.



### Что добавлено в симулятор

Класс пакета с полем upstreamQ, counterInc
Класс для распределения очередейц
Собственоо BFC свитч
